# e5f60df786e9da9850b7f01480ebffced3be396618c230fa94b5cbc846723553

## Download URL

https://bazaar.abuse.ch/sample/e5f60df786e9da9850b7f01480ebffced3be396618c230fa94b5cbc846723553/

## Static Analysis

### File Hashes

| Hash Type     | Hash Value                                                                                                 |
|---------------|------------------------------------------------------------------------------------------------------------|
| **SHA256**    | `e5f60df786e9da9850b7f01480ebffced3be396618c230fa94b5cbc846723553`                                         |
| **SHA3-384**  | `b84fdf4dc3d45f6ed547c43620700796d6ca2074aa4a837305a4a036bb11ca5fad9fd84ed70fdb4005ea2cf0198524a8`         |
| **SHA1**      | `5d4b97bbf2ca874b5924ec489c90a2e109ae2ad6`                                                                 |
| **MD5**       | `8b42ebfba0cb67a1164a15c6dae6fbef`                                                                         |


### Size, Entropy and Architecture

* **Size**: 590848 bytes
* **Entropy**: 7.830
* **Architecture**: Intel 386 (32 bit)

### Imported DDL's

* user32.dll
* kernel32.dll
* shell32.dll
* advapi32.dll
* shlwapi.dll
* gdi32.dll
* comctl32.dll


### Principal Imported Functions

* CryptAcquireContextA
* CryptCreateHash
* CryptDestroyHash
* CryptGetHashParam
* CryptHashData
* CryptReleaseContext
* ShellExecuteA
* ReadFile
* WriteFile
* GetFileSize
* FindFirstFileA
* FindNextFileA
* PathFindExtensionA
* PathFindFileNameA
* RegCloseKey
* RegCreateKeyExA
* RegDeleteKeyA


![Functions Imported](./images/functions_1.png)

![Functions Imported](./images/functions_2.png)

### Strings

| Section Type | Content                                                                                                     |
|--------------|-------------------------------------------------------------------------------------------------------------|
| `.text`      | `/c del`                                                                                                    |
| `.data`      | `HOW TO DECRYPT FILES.txt`                                                                                  |
| `.data`      | `SOFTWARE\Microsoft\Windows\CurrentVersion\Run`                                                             |
| `.data`      | `0p3nSOurc3 X0r157, motherfucker!`                                                                          |
| `.data`      | `pussylicker`                                                                                               |
| `.data`      | `Files have been decrypted successfully!`                                                                   |
| `.data`      | `Password is incorrect!`                                                                                    |
| `.data`      | `Attention! All your files were encrypted!\r\nTo decrypt files, please enter correct password!`             |
| `.data`      | `You have reached a limit of attempts - your data is irrevocably broken.`                                   |
| `.data`      | `Entered password is correct. Press OK to start decrypting of files. Dont close window and wait until message "Files have been decrypted successfully!" appears.` |
| `.data`      | `CRYPTED!`                                                                                                  |
| `.data`      | `Attention!`                                                                                                |



![Strings 1](./images/strings_1.png)
![Strings 2](./images/strings_2.png)
![Strings 3](./images/strings_3.png)


### Resource Section

This malware has in his resource section three files, beeing then:

* Image: with some instructions on how to contact the malware author to decrypt the files
* Bigger BMP: contains a lot of content like the ransom note, file extensions and other things
* Smaller BMP: nothing relevant

![Resource Content](./images/resources.png)



## Dynamic Analysis Overview

The first thing that this malware does is to recover the content of the biggest .BMP file in his resource section. After that he uses the first line of the file to decrypt the rest of the content.


![Resource Content](./images/resource_big_content.png)

We can achieve this result with this simple code:

```c
#include <stdio.h>

int main(const int argc, const char * argv[]) {
  FILE * pInputFile = NULL;
  unsigned int iKey[16] = { 0 }, iCurrentValue = 0, iCounter = 0;

  if(argc < 2) {
    printf("\"%s\" Usage: <INPUT FILE>\n", argv[0]);
    return 1;
  }

  pInputFile = fopen(argv[1], "rb");
  if(!pInputFile) {
    printf("[-] The program was not able to open/create the file!\n");
    return 1;
  }

  // The Decryption "Key" Bytes
  // 0x5E, 0x34, 0xCD, 0xA1, 0xBF, 0xC6, 0x04, 0x92, 0x62, 0x19, 0x52, 0xFF, 0x8E, 0x0A, 0x74, 0x14
  for(unsigned int i = 0; i < 16; i++)
    iKey[i] = fgetc(pInputFile);

  while((iCurrentValue = fgetc(pInputFile)) != EOF) {
    printf("%c", iCurrentValue ^ iKey[iCounter++]);

    if(iCounter > 0 && iCounter % 16 == 0) printf("\n");
    if((iCounter + 1)  == 17) iCounter = 0;
  }

  if(pInputFile)
    fclose(pInputFile);

  return 0;
}
```

![Big Content Decrypted](./images/resource_big_content_decrypted_one.png)
![Big Content Decrypted Two](./images/resource_big_content_decrypted_two.png)


Before continuing he reverse the bytes of the "Decryption Key" to use later.

He gets the timestamp of Last Edition, Created at and Last Open from the Explorer.exe application, so them every file that he creates or modify, it will set this timestamps.

He gets the path to the TEMP folder and his path, so it copies itself to address C:\Users\User\AppData\Local\Temp\ with name the name of `E7OKC9s3IlhAd13.exe` and it changes the file times (Creation, Last Edition, Last Open) with the sames of Explorer.exe.

![Copying ItSelf to Temp Folder](./images/Copying_ItSelf_To_Temp_Folder.png)


Then he starts to modify/add some key on Windows Registry:

| Registry Key                                                                                                         | Value                                                                                       |
|----------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|
| HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run                                                       | C:\Users\User\AppData\Local\Temp\E7OKC9s3IlhAd13.exe                                      |
| HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run                                                        | C:\Users\User\AppData\Local\Temp\E7OKC9s3IlhAd13.exe                                      |
| HKEY_CLASSES_ROOT\ZJKCLJAUDZDACP                                                                                    | CRYPTED!                                                                                   |
| HKEY_CLASSES_ROOT\ZJKCLJAUDZDACP\shell\open\command                                                                  | C:\Users\User\AppData\Local\Temp\E7OKC9s3IlhAd13.exe                                      |
| HKEY_CLASSES_ROOT\.Remember_you_got_only_24_hours_to_make_the_payment_if_you_dont_pay_prize_will_triple_Mortal_Kombat_Ransomware | ZJKCLJAUDZDACP                                                                            |
| HKEY_CLASSES_ROOT\ZJKCLJAUDZDACP\DefaultIcon                                                                         | C:\Users\User\AppData\Local\Temp\E7OKC9s3IlhAd13.exe,0                                   |



![Registry One](./images/registry_one.png)
![Registry Two](./images/registry_one.png)
![Registry Three](./images/registry_one.png)
![Registry Four](./images/registry_one.png)
![Registry Five](./images/registry_one.png)

After that he get the logical drivers and runs through each one a recursive function that finds the next folder and files inside that folder. 

For every folder he verifies if already exists the ransom note, if not he creates.

He compares the extension of every file he encounters to verify if it has not been encrypted yet and if the file extension is in the "allowed extensions".

If he encounters a file that is not encrypted yet, he will prepare a string to be the new file name, that is the CURRENT NAME OF THE FILE + CUSTOM FILE EXTENSION. (Usually FILE_NAME.Remember_you_got_only_24_hours_to_make_the_payment_if_you_dont_pay_prize_will_triple_Mortal_Kombat_Ransomware)

He puts a file pointer in the beginning of the file, but he moves 0x4B in depth, and read up to maximum of 0x1A92F4 bytes.

Before start to encrypting the file content he creates a custom key to each file, being the XOR opertaion between the reversed bytes used to decrypt the content of resource section and the first letter of the file and some ROL operation as can be seeing below:

```c
#include <stdio.h>

int main() {
  unsigned char * FileName = "Lorem_ipsum.txt";
  unsigned int ReversedDecryptedKeyOfResourceSection[] = {0x14, 0x74, 0x0A, 0x8E, 0xFF, 0x52, 0x19, 0x62, 0x92, 0x04, 0xC6, 0xBF, 0xA1, 0xCD, 0x34, 0x5E};
  unsigned int FileInitialLetter = FileName[0];
  unsigned int Result[16] = { 0 };

  for(int i = 0, j = 0; i < 16; i++) {
    Result[i] = (FileInitialLetter ^  ReversedDecryptedKeyOfResourceSection[j]) & 0x000000FF;
    FileInitialLetter = (FileInitialLetter << 1) | (FileInitialLetter >> 7) & 0xFF;
    j++;
	}

	return 0;
}
```

Then he starts to encrypt the file content with something similar as can be seeing below:


```c
void XorEncryption(PBYTE pFileContent, PBYTE pToXORReversedKeyWithFileFirstLetter, DWORD dwBytesRead) {
        UINT FirstFourBytes = 0x0, Ebx = 0x0, SecondFourBytes = 0x0, iCounter = 0x0;

        for (int i = (dwBytesRead >> 3); i != 0; i--) {

                FirstFourBytes = *(UINT*)(pFileContent + iCounter);
                SecondFourBytes = *(UINT*)(pFileContent + iCounter + 4);

                FirstFourBytes = _byteswap_ulong(FirstFourBytes);
                SecondFourBytes = _byteswap_ulong(SecondFourBytes);

                while (Ebx != (0x9E3779B9 * 0x10)) {
                        Ebx += 0x9E3779B9;

                        FirstFourBytes += (((SecondFourBytes << 4) + *(UINT*)(pToXORReversedKeyWithFileFirstLetter)) ^ (Ebx + SecondFourBytes)) ^ ((SecondFourBytes >> 5) + *(UINT*)(pToXORReversedKeyWithFileFirstLetter + 4));

                        SecondFourBytes += (((FirstFourBytes << 4) + *(UINT*)(pToXORReversedKeyWithFileFirstLetter + 8)) ^ (Ebx + FirstFourBytes)) ^ ((FirstFourBytes >> 5) + *(UINT*)(pToXORReversedKeyWithFileFirstLetter + 12));
                }

                *(UINT*)(pFileContent + iCounter) = _byteswap_ulong(FirstFourBytes);
                *(UINT*)(pFileContent + iCounter + 4) = _byteswap_ulong(SecondFourBytes);

                FirstFourBytes = 0x0;
                SecondFourBytes = 0x0;
                Ebx = 0x0;
                iCounter += 8;
        }
}
```

And based on that we can write the decryption code and would be something like:


```c
void XorDecryption(PBYTE pFileContent, PBYTE pToXORReversedKeyWithFileFirstLetter, DWORD dwBytesRead) {
        printf("\t\t\tInit Decryption XOR Function!\n");
        UINT FirstFourBytes = 0x0, Ebx = (0x9E3779B9 * 0x10), SecondFourBytes = 0x0, iCounter = 0x0;

        for(int i = (dwBytesRead >> 3); i != 0; i--) {
                FirstFourBytes = *(UINT*)(pFileContent + iCounter);
                SecondFourBytes = *(UINT*)(pFileContent + iCounter + 4);

                FirstFourBytes = _byteswap_ulong(FirstFourBytes);
                SecondFourBytes = _byteswap_ulong(SecondFourBytes);

                while (Ebx != 0x0) {

                        SecondFourBytes -= (((FirstFourBytes << 4) + *(UINT*)(pToXORReversedKeyWithFileFirstLetter + 8)) ^ (Ebx + FirstFourBytes)) ^ ((FirstFourBytes >> 5) + *(UINT*)(pToXORReversedKeyWithFileFirstLetter + 12));

                        FirstFourBytes -= (((SecondFourBytes << 4) + *(UINT*)(pToXORReversedKeyWithFileFirstLetter)) ^ (Ebx + SecondFourBytes)) ^ ((SecondFourBytes >> 5) + *(UINT*)(pToXORReversedKeyWithFileFirstLetter + 4));

                        Ebx -= 0x9E3779B9;
                }

                *(UINT*)(pFileContent + iCounter) = _byteswap_ulong(FirstFourBytes);
                *(UINT*)(pFileContent + iCounter + 4) = _byteswap_ulong(SecondFourBytes);

                FirstFourBytes = 0x0; 
                SecondFourBytes = 0x0;
                Ebx = (0x9E3779B9 * 0x10);
                iCounter += 8;
        }
}
```


After Encrypting every single file with the XOR and Bit Rotation operation, it will show the user an dialog box with three buttons. 

One for submit the password, one for "help" (shows just a little message, saying that the files are encrypted) and other for exit.

![Window Shown](./images/Message_To_Decrypt.png)

Putting the wrong password:

![Wrong Password](./images/Password_Incorrect_Answer.png)

Putting the right password:

![Right Password](./images/Right_Password.png)

Every input will be used as base to an function that use MD5 algorithym to create an hash. The function that create this hash is called 5 times and the result of each one is used as the entrance for the next.

![Creating The Hash To Verify](./images/Acquiring_CryptHash_With_User_Input.png)

The result of this operation have to be equal as:

```
0x39 0x41 0xEB 0xAE 0xC6 0xFB 0x69 0x38 0xAB 0x8A 0xE8 0x95 0xF8 0xDD 0xE2 0x14 
```

![Validating User Input](./images/Validating_User_Input.png)

This key can be found in the resource content that the malware decrypts and contains all necessary information for it's work.

For last this is my Yara Rule for this malware:


```yaml
rule mortalkombatransomware {
        strings:
                $ransom_note = "HOW TO DECRYPT FILES.txt"
                $random_phrase = "0p3nSOurc3 X0r157, motherfucker!"
                $reg_path = "Alcmeter"
        condition:
                $ransom_note and
                $random_phrase and
                $reg_path and
                filesize < 591000 and
                pe.imports("kernel32.dll", "FindResourceA") and
                pe.imports("kernel32.dll", "GetLogicalDrives") and
                pe.imports("kernel32.dll", "WriteFile") and
                pe.imports("kernel32.dll", "ReadFile") and
                pe.imports("kernel32.dll", "FindFirstFileA") and
                pe.imports("kernel32.dll", "FindNextFileA") and
                pe.imports("advapi32.dll", "RegCreateKeyExA") and
                pe.imports("shell32.dll", "ShellExecuteA")
}
```
